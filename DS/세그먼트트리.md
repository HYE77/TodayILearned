# 세그먼트 트리란?

<aside>
💡

**배열의 구간에 대한 정보를 빠르게 계산하고 갱신하기 위한 트리 자료구조**

</aside>

- 구간 합 Range Sum
- 구간 최소/최대 Range Min/Max
- 구간 곱
- 특정 구간 조건 검사

## 왜 필요한가?

예를 들어 배열이 아래와 같을 때,

```java
[1, 3, 5, 7, 9, 11]
```

문제 1: 구간 합 구하기

- [1 ~ 4] 구간합 → 단순 계산 시 $O(N)$

문제 2: 값 변경

- arr[2] = 10으로 바뀌면? → 다시 누적합 계산 $O(N)$

세그먼트 트리를 이용하면

| **연산** | **시간복잡도** |
| --- | --- |
| 구간 쿼리 | O(log N) |
| 값 변경 | O(log N) |

# 구조

배열의 길이가 8이라고 가정하면

```
             [0~7]
         /            \
     [0~3]            [4~7]
    /     \          /      \
 [0~1]  [2~3]    [4~5]     [6~7]
```

### 특징

- 루트: 전체 구간
- 왼쪽 자식: 왼쪽 절만
- 오른쪽 자식: 오른쪽 절반
- 리프 노드: 개별 원소

## 핵심 원리

- 세 가지 경우로 쿼리 처리
- 구간 [L, R]을 조회할 때,
    - 완전히 포함 → 바로 반환
    - 완전히 벗어남 → 0 반환
    - 일부만 겹침 → 왼쪽 + 오른쪽 재귀 호출

# 기본 구현 (구간합)

### 트리 배열 크기

```
size ≈ 4 * N
```

### 코드

- `arr` : 원본 배열
- `tree` : 세그먼트 트리를 배열로 저장한 것
    - `tree[1]` : 루트 (전체 구간)
    - `tree[node * 2]` : 왼쪽 자식
    - `tree[node  * 2 + 1]` : 오른쪽 자식
- `n` : 배열 길이
- tree 크기를 `4*n`으로 잡은 이유 : 완전 이진트리 형태로 만들 때, 안전하게 충분한 공간을 확보하기 위해서 (정확한 최소값을 계산하기 귀찮아서 관례적으로 4*n 활용)

```java
class SegmentTree {
    int[] tree;
    int[] arr;
    int n;

    public SegmentTree(int[] arr) {
		    // 생성자
        this.arr = arr;
        this.n = arr.length;
        tree = new int[4 * n];
        build(1, 0, n - 1); // 루트노드부터 트리 채우기
    }

    // 트리 생성 (현재 노드가 담당하는 구간 [start, end]를 트리에 저장
    private void build(int node, int start, int end) {
        if (start == end) {
		        // 리프노드라면 (원소 1개)
            tree[node] = arr[start];
        } else { // 리프가 아니라면
            int mid = (start + end) / 2;
            build(node * 2, start, mid);
            build(node * 2 + 1, mid + 1, end);
            tree[node] = tree[node * 2] + tree[node * 2 + 1];
        }
    }

    // 구간 합 쿼리
    public int query(int node, int start, int end, int left, int right) {
        if (right < start || end < left) {
            return 0; // 범위 밖 (전혀 안 겹침)
        }

        if (left <= start && end <= right) {
            return tree[node]; // 완전 포함 
        }

				// 일부 겹침 (Partial)
        int mid = (start + end) / 2;
        int lsum = query(node * 2, start, mid, left, right);
        int rsum = query(node * 2 + 1, mid + 1, end, left, right);
        return lsum + rsum;
    }

    // 값 업데이트 (원소 1개 변경)
    public void update(int node, int start, int end, int idx, int val) {
        if (start == end) {
            tree[node] = val;
            return;
        }

        int mid = (start + end) / 2;
        if (idx <= mid)
            update(node * 2, start, mid, idx, val);
        else
            update(node * 2 + 1, mid + 1, end, idx, val);

        tree[node] = tree[node * 2] + tree[node * 2 + 1];
    }
}
```

# 시간복잡도

- 트리 높이 : $log_2 N$
    - 매 단계마다 절반씩 나눔
    - 최대 깊이만큼만 탐색

# 구간합 외 세그먼트 트리

### 구간 최소/최대 Range Min/Max

- `tree[node] = min(leftChild, rightChild)`
- query의 “범위 밖” 반환값은
    - `min (Integer.MAX_VALUE)`
    - `max (Integer.MIN_VALUE)`

### 구간 곱 Range Product, mod 포함 가능

- `tree[npde] = (left * right) % MOD`
- 범위 밖 값은 곱의 항등원인 `1`

### 구간 gcd/lcm

- `tree[node] = gcd(left, right)`
- 범위 밖 값은 0 (gcd(a, 0) = a)

### 구간에서 가장 큰 값 + 두 번째로 큰 값

- 노드에 단일 int가 아니라 (max1, max2) 같은 구조 저장
- merge 시 두 구간의 후보 4개 중 상위 2개 뽑기

### 구간 내 조건 개수 (예: 0의 개수, 음의 개수)

- 노드에 count 저장
- update 시 해당 leaf 변화 반영

# 언제 사용하나?

- 구간합이 자주 필요할 때
- 값 변경이 자주 일어날 때
- 누적합으로 해결 불가능한 경우
- 온라인 쿼리 문제

# 세그먼트 트리 vs 다른 구조

| **구조** | **구간합** | **업데이트** |
| --- | --- | --- |
| 단순 배열 | O(N) | O(1) |
| 누적합 | O(1) | O(N) |
| 세그먼트 트리 | O(logN) | O(logN) |
| Fenwick Tree | O(logN) | O(logN) |

---

# ➕ (참고) 펜윅 트리 Fenwick Tree, Binary Indexed Tree

- 세그먼트 트리와 비슷하게 점 업데이트
- 구간합 또는 prefix sum을 $O(logN)$에 처리하는 자료구조

## 목적

- 배열 `arr[1..N]` 이 있을 때
    - arr[x] 값이 바뀜 (점 업데이트)
    - 1.. k 까지 합 (prefix sum) 또는 l..r 합 (구간합)을 자주 물어봄
- 위 두 가지를 $O(logN)$에 하려고 많은 구조

## 핵심 아이디어

<aside>
💡

**`tree[i]`는 i로 끝나는 어떤 구간의 합을 저장한다!**

</aside>

- 이 어떤 구간 길이가 i의 최하위 1비트(LSB)로 결정됨.

### LSB(i)

- `lsb(i) = i & -i`
- i를 이진수로 쓰면, 맨 오른쪽에 있는 1 ← 이 1이 의미하는 값이 `lsb(i)`

<aside>
💡

$i=12$ → $1100_2$ 

맨 오른쪽1은 $100_2$ → 값은 4

$lsb(12) = 4$

</aside>

- `tree[i]`는 길이 lsb(i)인 구간의 합을 저장
    - 구간 : `(i - lsb(i) + 1) ~ i`
