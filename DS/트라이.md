# ê°œë…

- ë¬¸ìì—´ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì €ì¥í•˜ê³  íƒìƒ‰í•˜ê¸° ìœ„í•œ íŠ¸ë¦¬ ê¸°ë°˜ ìë£Œêµ¬ì¡°
    
    <img width="800" height="750" alt="image" src="https://github.com/user-attachments/assets/ba81c253-f11b-4853-9349-3387bf7449d6" />

    
- **Prefix Tree** (ì ‘ë‘ì‚¬ íŠ¸ë¦¬)ë¼ê³ ë„ ë¶€ë¦„
- ìš°ë¦¬ê°€ ê²€ìƒ‰í•  ë•Œ ë³¼ ìˆ˜ ìˆëŠ”Â **ìë™ì™„ì„± ê¸°ëŠ¥, ì‚¬ì „ ê²€ìƒ‰ ë“± ë¬¸ìì—´ì„ íƒìƒ‰í•˜ëŠ”ë° íŠ¹í™”ë˜ì–´ìˆëŠ” ìë£Œêµ¬ì¡°**

<aside>
ğŸ’¡

- ê° ë…¸ë“œëŠ” í•˜ë‚˜ì˜ ë¬¸ì characterë¥¼ ë‚˜íƒ€ëƒ„
- ë£¨íŠ¸ ë…¸ë“œ: ë¹ˆ ë¬¸ìì—´
- ê²½ë¡œ path: í•˜ë‚˜ì˜ ë‹¨ì–´ë¥¼ êµ¬ì„±
- ê³µí†µ ì ‘ë‘ì‚¬ëŠ” ê°™ì€ ê²½ë¡œë¥¼ ê³µìœ 
</aside>

# ì™œ ì‚¬ìš©í•˜ëŠ”ê°€?

ë¬¸ìì—´ì˜ ê¸¸ì´ë¥¼ L, ë°ì´í„°(ë‹¨ì–´)ì˜ ê°œìˆ˜ê°€ Nì´ë¼ê³  í–ˆì„ ë•Œ

| **ìë£Œêµ¬ì¡°** | **ë¬¸ìì—´ ê²€ìƒ‰ ì‹œê°„** |
| --- | --- |
| ë°°ì—´/ë¦¬ìŠ¤íŠ¸ | O(N) |
| ì •ë ¬ + ì´ì§„íƒìƒ‰ | O(log N) |
| **Trie** | **O(L)** |
- ë°ì´í„°ì˜ ê°œìˆ˜ Nê³¼ ë¬´ê´€
- ì ‘ë‘ì‚¬ ê²€ìƒ‰ì— ë§¤ìš° ê°•ë ¥í•¨

# ì£¼ìš” ì—°ì‚°

### ì‚½ì… Insert

- ë¬¸ì í•˜ë‚˜ì”© ë‚´ë ¤ê°€ë©´ì„œ ë…¸ë“œ ìƒì„±

```java
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEnd;
}

class Trie {
    TrieNode root = new TrieNode();

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEnd = true;
    }
}
```

- ì‹œê°„ë³µì¡ë„ $O(L)$

### ê²€ìƒ‰ Search

```java
public boolean search(String word) {
    TrieNode node = root;
    for (char c : word.toCharArray()) {
        int idx = c - 'a';
        if (node.children[idx] == null) {
            return false;
        }
        node = node.children[idx];
    }
    return node.isEnd;
}
```

- ì‹œê°„ë³µì¡ë„ $O(L)$

### ì ‘ë‘ì‚¬ ê²€ìƒ‰ startsWith

- í•´ë‹¹ ì ‘ë‘ì‚¬ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ê°€ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ì—°ì‚°

```java
public boolean startsWith(String prefix) {
    TrieNode node = root;
    for (char c : prefix.toCharArray()) {
        int idx = c - 'a';
        if (node.children[idx] == null) {
            return false;
        }
        node = node.children[idx];
    }
    return true;
}
```

- ì‹œê°„ë³µì¡ë„ $O(L)$

# íŠ¸ë¼ì´ì˜ íŠ¹ì§•

### ì¥ì 

- ì ‘ë‘ì‚¬ ê²€ìƒ‰ì´ ë§¤ìš° ë¹ ë¦„
- ìë™ì™„ì„± ê¸°ëŠ¥ êµ¬í˜„ì— ì í•©
- ì‚¬ì „ dictionary êµ¬í˜„ì— ì í•©
- ë¬¸ìì—´ ê°œìˆ˜ì— ì˜í–¥ì„ ëœ ë°›ìŒ

### ë‹¨ì 

- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ í¼
- ìì‹ ë…¸ë“œ ë°°ì—´ (26ê°œ ë“±)ì´ ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŒ

â†’ ì´ë¥¼ ê°œì„ í•œ êµ¬ì¡°: **Map ê¸°ë°˜ Trie**, **ì••ì¶• íŠ¸ë¼ì´ (Radix Tree)**, **Ternary Search Tree**

# ì–¸ì œ ì‚¬ìš©í•˜ë©´ ì¢‹ì€ê°€?

- ë¬¸ìì—´ ìë™ ì™„ì„±
- ì‚¬ì „ ê²€ìƒ‰
- ë‹¨ì–´ ê°œìˆ˜ ì„¸ê¸°
- ë¬¸ìì—´ ì§‘í•© ë¬¸ì œ
- ì ‘ë‘ì‚¬ ê¸°ë°˜ í•„í„°ë§
- ì „í™”ë²ˆí˜¸ ëª©ë¡ ë¬¸ì œ

---

# Map ê¸°ë°˜ Trie

## ê°œë…

<aside>
ğŸ’¡

**ê° TrieNodeê°€ Map<Character, TrieNode> ìì‹ë“¤ì„ ê°€ì§„ë‹¤**

ë…¸ë“œ â†’ ë§µ â†’ (ë‹¤ìŒ ë…¸ë“œ) â†’ ë˜ ë§µ â†’ â€¦

</aside>

- ê¸°ì¡´

```java
TrieNode[] children = new TrieNode[26];
```

- ê°œì„ 

```java
Map<Character, TrieNode> childern = new HashMap<>();
```

### ì°¨ì´ì 

- ìì‹ì´ ìˆëŠ” ë¬¸ìë§Œ ì €ì¥
- í•„ìš”í•  ë•Œë§Œ ë…¸ë“œ ìƒì„±

### Map Trie ë…¸ë“œ êµ¬ì¡° ì˜ˆì‹œ

```java
import java.util.HashMap;
import java.util.Map;

class TrieNode {
    Map<Character, TrieNode> children = new HashMap<>();
    boolean isEnd;
}

class Trie {
    private final TrieNode root = new TrieNode();

    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            node = node.children.computeIfAbsent(ch, k -> new TrieNode());
        }
        node.isEnd = true;
    }

    public boolean startsWith(String prefix) {
        TrieNode node = root;
        for (int i = 0; i < prefix.length(); i++) {
            node = node.children.get(prefix.charAt(i));
            if (node == null) return false;
        }
        return true;
    }

    public boolean search(String word) {
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            node = node.children.get(word.charAt(i));
            if (node == null) return false;
        }
        return node.isEnd;
    }
}
```

### ì¥ì 

- ë©”ëª¨ë¦¬ ì ˆì•½ (í¬ì†Œ íŠ¸ë¦¬ì—ì„œ ë§¤ìš° íš¨ê³¼ì )
- ë¬¸ì ë²”ìœ„ ì œí•œ ì—†ìŒ (Unicode ê°€ëŠ¥)

### ë‹¨ì 

- ë°°ì—´ë³´ë‹¤ ì ‘ê·¼ ì†ë„ ëŠë¦¼
- HashMap ì˜¤ë²„í—¤ë“œ ì¡´ì¬

## ì–¸ì œ ì“°ë©´ ì¢‹ì„ê¹Œ?

- ì•ŒíŒŒë²³ ë²”ìœ„ê°€ ë„“ì„ ë•Œ
- ë°ì´í„°ê°€ ì ê³  sparseí•  ë•Œ
- ì‹¤ë¬´ì—ì„œ ì¼ë°˜ì ìœ¼ë¡œ ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ë°©ì‹

# ì••ì¶• íŠ¸ë¼ì´ Radix Tree/Compressed Trie

## ê°œë…

- ê¸°ì¡´ TrieëŠ” í•œê¸€ìì”© ë…¸ë“œë¥¼ ê°€ì§
- ì••ì¶• TrieëŠ” ì—°ì†ëœ ë‹¨ì¼ ê²½ë¡œë¥¼ í•˜ë‚˜ì˜ ë…¸ë“œë¡œ í•©ì¹¨

## í•µì‹¬ ì•„ì´ë””ì–´

<aside>
ğŸ’¡

**ìì‹ì´ í•˜ë‚˜ë¿ì¸ ë…¸ë“œë“¤ì€ í•©ì³ë²„ë¦¬ì**

</aside>

<img width="251" height="201" alt="image" src="https://github.com/user-attachments/assets/5064e0a1-b11c-4e1f-b264-2553947d9c48" />


### ì¥ì 

- ë…¸ë“œ ìˆ˜ ëŒ€í­ ê°ì†Œ
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê°ì†Œ
- íŠ¸ë¦¬ ë†’ì´ ê°ì†Œ â†’ íƒìƒ‰ ë¹ ë¦„

### ë‹¨ì 

- êµ¬í˜„ ë³µì¡
- ì‚½ì…/ì‚­ì œ ì‹œ ë¬¸ìì—´ ë¶„í•  í•„ìš”

### ì‚¬ìš© ì˜ˆ

- ë¼ìš°íŒ… í…Œì´ë¸” (IP prefix matching)
- ëŒ€ê·œëª¨ ë¬¸ìì—´ ì‚¬ì „

### ì••ì¶• íŠ¸ë¼ì´ ì‚½ì… ì½”ë“œ

```java
import java.util.HashMap;
import java.util.Map;

class RadixNode {
    boolean isEnd;
    // key: edge label (ì—¬ëŸ¬ ê¸€ì), value: child node
    Map<String, RadixNode> children = new HashMap<>();
}

public class RadixTree {
    private final RadixNode root = new RadixNode();

    public void insert(String word) {
        insert(root, word);
    }

    private void insert(RadixNode node, String word) {
        if (word.isEmpty()) {
            node.isEnd = true;
            return;
        }

        // 1) í˜„ì¬ ë…¸ë“œì˜ ëª¨ë“  edge label ì¤‘ì—ì„œ wordì™€ ê³µí†µ prefixê°€ ìˆëŠ” edgeë¥¼ ì°¾ëŠ”ë‹¤
        for (Map.Entry<String, RadixNode> entry : node.children.entrySet()) {
            String edge = entry.getKey();
            RadixNode child = entry.getValue();

            int common = commonPrefixLength(edge, word);
            if (common == 0) continue;

            // Case A: edgeê°€ wordì˜ prefixì¸ ê²½ìš° (edge ì „ì²´ë¥¼ íƒ€ê³  ë‚´ë ¤ê°)
            // edge="app", word="apple" => childë¡œ ë‚´ë ¤ê°€ì„œ "le" ì‚½ì…
            if (common == edge.length()) {
                insert(child, word.substring(common));
                return;
            }

            // Case B: wordê°€ edgeì˜ prefixì¸ ê²½ìš° (wordê°€ ì¤‘ê°„ì—ì„œ ëë‚¨)
            // edge="apple", word="app" => edgeë¥¼ "app" + "le"ë¡œ split
            if (common == word.length()) {
                // split: ê¸°ì¡´ childë¥¼ ì•„ë˜ë¡œ ë‚´ë¦¬ê³  ì¤‘ê°„ë…¸ë“œë¥¼ ë§Œë“ ë‹¤
                String edgeRemainder = edge.substring(common); // "le"
                RadixNode mid = new RadixNode();
                mid.isEnd = true; // word="app"ê°€ ë

                // ê¸°ì¡´ childë¥¼ mid ì•„ë˜ë¡œ ì¬ì—°ê²°
                mid.children.put(edgeRemainder, child);

                // ê¸°ì¡´ edge ì œê±° í›„, "app" -> mid ë¡œ êµì²´
                node.children.remove(edge);
                node.children.put(word, mid);
                return;
            }

            // Case C: ì¼ë¶€ë§Œ ê³µí†µì´ê³  ë‘˜ ë‹¤ ë” ë‚¨ëŠ” ê²½ìš° (ë¶„ê¸° ë°œìƒ)
            // edge="car", word="cat" => common="ca"
            String commonPrefix = edge.substring(0, common);    // "ca"
            String edgeRemainder = edge.substring(common);      // "r"
            String wordRemainder = word.substring(common);      // "t"

            RadixNode mid = new RadixNode(); // ê³µí†µ prefix ë…¸ë“œ(ì¤‘ê°„ ë…¸ë“œ)

            // ê¸°ì¡´ childëŠ” edgeRemainderë¡œ ë‚´ë ¤ê°€ê²Œ
            mid.children.put(edgeRemainder, child);

            // ìƒˆë¡œ ë“¤ì–´ì˜¨ wordRemainderë„ ì¶”ê°€
            RadixNode newChild = new RadixNode();
            newChild.isEnd = true; // wordê°€ ì—¬ê¸°ì„œ ëë‚œë‹¤ê³  ê°€ì •? -> ì•„ë˜ insert ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í•´ë„ ë¨
            // wordRemainderê°€ ë” ê¸¸ ìˆ˜ ìˆìœ¼ë‹ˆ insertë¡œ ì²˜ë¦¬
            insert(newChild, ""); // isEnd ì„¸íŒ…
            mid.children.put(wordRemainder, newChild);

            node.children.remove(edge);
            node.children.put(commonPrefix, mid);
            return;
        }

        // 2) ê³µí†µ prefixë¥¼ ê³µìœ í•˜ëŠ” edgeê°€ í•˜ë‚˜ë„ ì—†ë‹¤ë©´ ìƒˆ edge ì¶”ê°€
        RadixNode newNode = new RadixNode();
        newNode.isEnd = true;
        node.children.put(word, newNode);
    }

    private int commonPrefixLength(String a, String b) {
        int n = Math.min(a.length(), b.length());
        int i = 0;
        while (i < n && a.charAt(i) == b.charAt(i)) i++;
        return i;
    }
}
```

# Ternary Search Tree (TST)

![image.png](attachment:28d514ad-df62-4f17-b647-f2cb77147e62:image.png)

## ê°œë…

- Trie + BSTì˜ í˜¼í•© êµ¬ì¡°
- ê° ë…¸ë“œëŠ”

```java
char c;
left (ì‘ì€ ë¬¸ì)
middle (ê°™ì€ ë¬¸ì -> ë‹¤ìŒ ê¸€ì)
right (í° ë¬¸ì)
```

- êµ¬ì¡°

```java
        m
       / \
      a   z
       \
        p
         \
          p
```

### ë™ì‘ ì›ë¦¬

ë¬¸ìë¥¼ ë¹„êµ:

- ì‘ìœ¼ë©´ left
- í¬ë©´ right
- (ì°¾ëŠ” ë¬¸ìì™€) ê°™ìœ¼ë©´ middle (ê·¸ë¦¬ê³  ë‹¤ìŒ ë¬¸ì ì°¾ê¸°)

### TST êµ¬í˜„ (ì‚½ì…/ê²€ìƒ‰/prefix)

```java
class TstNode {
    char c;
    boolean isEnd;
    TstNode left, eq, right;

    TstNode(char c) { this.c = c; }
}

public class TST {
    private TstNode root;

    public void insert(String word) {
        if (word == null || word.isEmpty()) return;
        root = insert(root, word, 0);
    }

    private TstNode insert(TstNode node, String word, int i) {
        char ch = word.charAt(i);

        if (node == null) node = new TstNode(ch);

        if (ch < node.c) {
            node.left = insert(node.left, word, i);
        } else if (ch > node.c) {
            node.right = insert(node.right, word, i);
        } else {
            // ê°™ì€ ë¬¸ìë©´ ë‹¤ìŒ ê¸€ì(=eq)ë¡œ
            if (i == word.length() - 1) {
                node.isEnd = true;
            } else {
                node.eq = insert(node.eq, word, i + 1);
            }
        }
        return node;
    }

    public boolean search(String word) {
        TstNode node = getNode(word);
        return node != null && node.isEnd;
    }

    public boolean startsWith(String prefix) {
        return getNode(prefix) != null;
    }

    // prefix/wordì˜ "ë§ˆì§€ë§‰ ê¸€ìì— í•´ë‹¹í•˜ëŠ” ë…¸ë“œ"ë¥¼ ì°¾ì•„ ë°˜í™˜
    private TstNode getNode(String s) {
        if (s == null || s.isEmpty()) return null;
        TstNode node = root;
        int i = 0;

        while (node != null) {
            char ch = s.charAt(i);

            if (ch < node.c) node = node.left;
            else if (ch > node.c) node = node.right;
            else {
                if (i == s.length() - 1) return node;
                i++;
                node = node.eq;
            }
        }
        return null;
    }
}
```

### ì‹œê°„ë³µì¡ë„

- í‰ê·  $O(L)$
- ìµœì•… $O(L log \sigma)$ Ïƒ=ë¬¸ì ì§‘í•© í¬ê¸°

### ì¥ì 

- ë°°ì—´ë³´ë‹¤ ë©”ëª¨ë¦¬ íš¨ìœ¨ì 
- Mapë³´ë‹¤ ë¹ ë¥¼ ìˆ˜ ìˆìŒ
- ê· í˜• ì¡íˆë©´ íš¨ìœ¨ì 

### ë‹¨ì 

- ê· í˜• ê¹¨ì§€ë©´ ì„±ëŠ¥ ì €í•˜
- êµ¬í˜„ ë‚œì´ë„ ë†’ìŒ

---

# ì „ì²´ ë¹„êµ

| **êµ¬ì¡°** | **ë©”ëª¨ë¦¬** | **ì†ë„** | **êµ¬í˜„ ë‚œì´ë„** |
| --- | --- | --- | --- |
| ê¸°ë³¸ Trie | âŒ í¼ | â­ ë¹ ë¦„ | ì‰¬ì›€ |
| Map Trie | â­• ì ˆì•½ | â­ ë³´í†µ | ì‰¬ì›€ |
| ì••ì¶• Trie | â­ ë§¤ìš° ì ˆì•½ | â­â­ ë¹ ë¦„ | ì–´ë ¤ì›€ |
| TST | â­• ì ˆì•½ | â­â­ ë¹ ë¦„ | ì–´ë ¤ì›€ |
